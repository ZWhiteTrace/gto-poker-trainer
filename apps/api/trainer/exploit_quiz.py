"""
Exploit Quiz Engine (Layer 1.5: Exploit Override)

在 GTO Logic Quiz 基礎上，疊加「台北線下剝削系統」。
支援兩種新題型：
  C (對手類型剝削): 面對某類型對手，如何調整 GTO 策略？
  D (Rake 感知): 在高抽水環境中，這個動作還值得嗎？
"""

import json
import random
from pathlib import Path
from typing import List, Optional

from trainer.logic_quiz import LogicQuizEngine, LogicQuestion

# 資料目錄
DATA_DIR = Path(__file__).parent.parent / "data"
EXPLOIT_DIR = DATA_DIR / "exploit"
ARCHETYPES_PATH = EXPLOIT_DIR / "archetypes.json"
OVERRIDES_PATH = EXPLOIT_DIR / "overrides.json"
RAKE_PATH = EXPLOIT_DIR / "rake_adjustments.json"


class ExploitQuizEngine:
    """台北線下剝削題目生成引擎"""

    def __init__(self):
        self.logic_engine = LogicQuizEngine()
        self.archetypes = self._load_archetypes()
        self.overrides = self._load_overrides()
        self.rake_data = self._load_rake()

    def _load_archetypes(self) -> dict:
        if not ARCHETYPES_PATH.exists():
            return {}
        with open(ARCHETYPES_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
        return data.get("archetypes", {})

    def _load_overrides(self) -> dict:
        if not OVERRIDES_PATH.exists():
            return {}
        with open(OVERRIDES_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
        return data.get("overrides", {})

    def _load_rake(self) -> dict:
        if not RAKE_PATH.exists():
            return {}
        with open(RAKE_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
        return data

    def get_archetype_names(self) -> List[str]:
        """取得所有 archetype 的 key"""
        return list(self.archetypes.keys())

    def get_archetype_display_name(self, key: str) -> str:
        """取得 archetype 的顯示名稱"""
        arch = self.archetypes.get(key, {})
        return arch.get("name", key)

    def get_rake_levels(self) -> List[str]:
        """取得所有 rake level 的 key"""
        return list(self.rake_data.get("rake_levels", {}).keys())

    def _format_role(self, role: str) -> str:
        """將 role 代碼轉為可讀中文"""
        return self.logic_engine._format_role(role)

    def _find_exploit_adjustment(
        self, archetype: str, scenario: str, hand: str
    ) -> Optional[dict]:
        """從 overrides 中找出特定場景/手牌的 exploit 調整"""
        override = self.overrides.get(archetype, {})
        examples = override.get("example_adjustments", [])
        for ex in examples:
            if ex.get("scenario") == scenario and ex.get("hand") == hand:
                return ex
        return None

    def _infer_exploit_action(
        self, archetype: str, gto_role: str
    ) -> Optional[dict]:
        """
        根據 archetype 的 override 規則推斷 exploit 調整。
        返回 {"action": str, "reason": str} 或 None。
        """
        override = self.overrides.get(archetype, {})

        # 對 bluff 類型的 GTO action 進行調整
        if gto_role in ("bluff_3bet", "bluff_4bet"):
            if archetype == "station":
                return {
                    "action": "fold",
                    "reason": "跟注站不棄牌，bluff 沒有 fold equity。改為棄牌。",
                }
            elif archetype == "nit":
                return {
                    "action": gto_role,
                    "reason": "Nit 的 fold 頻率極高，bluff 更有效。維持甚至增加。",
                }
            elif archetype == "aggro_fish":
                return {
                    "action": "fold",
                    "reason": "Aggro Fish 可能 4bet/raise 回來。不要對他詐唬。",
                }

        # 對 mix 類型的調整
        if gto_role == "mix_call_3bet":
            if archetype == "station":
                return {
                    "action": "call",
                    "reason": "不 3bet bluff，但 call 後可打價值。維持 call。",
                }
            elif archetype == "aggro_fish":
                return {
                    "action": "call",
                    "reason": "Flat call 設陷阱，讓他翻後自爆。不要 3bet 嚇跑他。",
                }

        # 對 value 類型的調整
        if gto_role in ("value_3bet", "value_4bet"):
            if archetype == "station":
                return {
                    "action": gto_role,
                    "reason": "價值端維持甚至加大。他會用差牌付你。",
                }
            elif archetype == "aggro_fish":
                return {
                    "action": "call",
                    "reason": "Flat call 設陷阱更好。3bet 讓他棄掉差牌 (你不想這樣)。",
                }

        # 對 call 類型的調整
        if gto_role == "call":
            if archetype == "nit":
                return {
                    "action": "fold",
                    "reason": "Nit 的 open range 極強。原本的 call 邊際到不值得。",
                }

        # honest_player 調整
        if archetype == "honest_player":
            if gto_role in ("bluff_3bet", "bluff_4bet"):
                return {
                    "action": gto_role,
                    "reason": "誠實玩家翻前不常 4bet bluff，你的 3bet bluff 有更多 fold equity。維持。",
                }
            if gto_role in ("value_3bet", "value_4bet"):
                return {
                    "action": gto_role,
                    "reason": "維持 GTO 價值端。誠實玩家不會用差牌 4bet，你的 value 3bet 安全。",
                }
            if gto_role == "mix_call_3bet":
                return {
                    "action": "call",
                    "reason": "Flat call 觀察翻後。誠實玩家翻後 sizing 洩漏資訊，可據此精準決策。",
                }

        # reg_lite 調整
        if archetype == "reg_lite":
            if gto_role == "mix_call_3bet":
                return {
                    "action": "value_3bet",
                    "reason": "Reg-lite 面對 3bet 容易過度棄牌 (MDF 計算不精確)。升級為 3bet 更好。",
                }
            if gto_role in ("value_3bet", "value_4bet"):
                return {
                    "action": gto_role,
                    "reason": "維持價值端。Reg-lite 會試圖「平衡防守」但在面對大注時崩潰。",
                }

        return None

    def _generate_exploit_distractors(
        self, correct_reason: str, archetype: str, count: int = 3
    ) -> List[str]:
        """生成 exploit 題的干擾選項"""
        arch_data = self.archetypes.get(archetype, {})
        misconceptions = arch_data.get("misconceptions", [])

        distractors = list(misconceptions)  # copy

        # 加入其他 archetype 的 exploit 邏輯作為干擾
        other_archetypes = [
            k for k in self.archetypes.keys() if k != archetype
        ]
        for other in other_archetypes:
            other_data = self.archetypes.get(other, {})
            other_insight = other_data.get("key_insight", "")
            if other_insight and other_insight != correct_reason:
                distractors.append(other_insight)

        # 加入一些通用錯誤
        generic_wrong = [
            "應該維持 GTO 平衡，不因對手類型改變策略",
            "無論對手是誰，頻率都應該一樣",
            "對手的傾向不影響翻前策略，只影響翻後",
            "Rake 高的環境應該更 aggressive，不是更保守",
            "線下賽應該更加 bluff heavy 因為面對面壓力大",
        ]
        for g in generic_wrong:
            if g not in distractors:
                distractors.append(g)

        random.shuffle(distractors)
        return distractors[:count]

    def generate_type_c(
        self,
        scenario: str = None,
        hand: str = None,
        archetype: str = None,
    ) -> Optional[LogicQuestion]:
        """
        生成 C 類題型：對手類型剝削
        「面對 {archetype} 型對手，{hand} 的 GTO 建議是 {action}，你應該如何調整？」
        """
        # 隨機選擇 archetype
        if not archetype:
            archetypes = self.get_archetype_names()
            if not archetypes:
                return None
            archetype = random.choice(archetypes)

        scenarios = self.logic_engine.get_available_scenarios()
        if not scenarios:
            return None

        # Retry logic: try multiple scenario/hand combos when random
        max_tries = 15 if (scenario is None and hand is None) else 1
        for _ in range(max_tries):
            s = scenario if scenario else random.choice(scenarios)
            hands = self.logic_engine.get_scenario_hands(s)
            if not hands:
                continue
            h = hand if hand else random.choice(hands)

            scenario_data = self.logic_engine.reasoning_data.get(s, {})
            hand_data = scenario_data.get("hands", {}).get(h, {})
            if not hand_data:
                continue

            gto_role = hand_data.get("role", "")

            adjustment = self._find_exploit_adjustment(archetype, s, h)
            if not adjustment:
                inferred = self._infer_exploit_action(archetype, gto_role)
                if not inferred:
                    continue
                adjustment = {
                    "gto_action": gto_role,
                    "exploit_action": inferred["action"],
                    "reason": inferred["reason"],
                }

            # Found a valid adjustment - use these values
            scenario = s
            hand = h
            break
        else:
            return None

        # 取得 GTO 建議
        scenario_data = self.logic_engine.reasoning_data.get(scenario, {})
        hand_data = scenario_data.get("hands", {}).get(hand, {})
        gto_role = hand_data.get("role", "")

        gto_action = adjustment.get("gto_action", gto_role)
        exploit_action = adjustment.get("exploit_action", gto_role)
        reason = adjustment.get("reason", "")

        # 判斷是否需要調整
        action_changed = (exploit_action != gto_action)

        arch_name = self.get_archetype_display_name(archetype)
        scenario_display = scenario.replace("_", " ")

        # 題目文字
        question_text = (
            f"在 {scenario_display} 場景中，{hand} 的 GTO 建議是 "
            f"{self._format_role(gto_action)}。\n"
            f"面對一位 {arch_name} 型對手，你應該如何調整？"
        )

        # 正確答案
        if action_changed:
            correct_answer = (
                f"調整為 {self._format_role(exploit_action)}：{reason}"
            )
        else:
            correct_answer = f"維持 {self._format_role(gto_action)}：{reason}"

        # 干擾選項
        distractors = self._generate_exploit_distractors(
            reason, archetype, count=3
        )

        # 組合選項
        options = [correct_answer] + distractors
        indices = list(range(len(options)))
        random.shuffle(indices)
        options = [options[i] for i in indices]
        correct_index = indices.index(0)

        # 解說
        arch_data = self.archetypes.get(archetype, {})
        explanation_parts = [
            f"對手類型：{arch_name}",
            f"特徵：{arch_data.get('description', '')}",
            f"",
            f"GTO 建議：{self._format_role(gto_action)}",
            f"Exploit 調整：{self._format_role(exploit_action)}",
            f"原因：{reason}",
        ]
        if arch_data.get("key_insight"):
            explanation_parts.append(f"\n核心洞察：{arch_data['key_insight']}")

        return LogicQuestion(
            question_type="C",
            question_text=question_text,
            options=options,
            correct_index=correct_index,
            explanation="\n".join(explanation_parts),
            tags_involved=[archetype],
            layer="Layer 1.5 (Exploit Override)",
            hand=hand,
            scenario=scenario,
        )

    def generate_type_d(
        self, rake_level: str = None
    ) -> Optional[LogicQuestion]:
        """
        生成 D 類題型：Rake 感知
        「這個動作在標準 rake 下 EV = +X。在台北 Y% rake 環境中還值得嗎？」
        """
        scenarios = self.rake_data.get("rake_impact_scenarios", [])
        if not scenarios:
            return None

        # 隨機選場景
        scenario = random.choice(scenarios)

        # 選 rake level
        if not rake_level:
            available_levels = []
            for level_key in ["taipei_low", "taipei_mid", "taipei_high"]:
                if level_key in scenario.get("rake_adjusted", {}):
                    available_levels.append(level_key)
            if not available_levels:
                return None
            rake_level = random.choice(available_levels)

        adjusted = scenario.get("rake_adjusted", {}).get(rake_level)
        if not adjusted:
            return None

        gto_context = scenario.get("gto_context", {})
        rake_levels = self.rake_data.get("rake_levels", {})
        level_info = rake_levels.get(rake_level, {})

        verdict = adjusted.get("verdict", "")
        gto_ev = gto_context.get("gto_ev_bb", 0)
        adjusted_ev = adjusted.get("adjusted_ev_bb", 0)
        rake_cost = adjusted.get("rake_cost_bb", 0)

        # 題目文字
        scenario_name = scenario.get("name", "")
        level_name = level_info.get("name", rake_level)
        rake_pct = level_info.get("rake_pct", 5)

        question_text = (
            f"場景：{scenario_name}\n"
            f"{scenario.get('description', '')}\n\n"
            f"在標準線上環境 (低 rake) 中，此動作 EV = +{gto_ev:.1f}bb。\n"
            f"在 {level_name} 環境 ({rake_pct}% rake) 中，這個動作還值得嗎？"
        )

        # 生成選項
        explanation = adjusted.get("explanation", "")

        if verdict == "negative":
            correct_answer = f"不值得 (EV = {adjusted_ev:+.1f}bb)：{explanation}"
            wrong_answers = [
                f"仍然值得 (EV 仍正)：rake 不影響翻前/翻後策略",
                f"取決於位置：有位置時仍可獲利",
                f"應該加大 sizing 來彌補 rake 損失",
            ]
        elif verdict == "positive" or verdict == "still_positive":
            correct_answer = f"仍然值得 (EV = +{adjusted_ev:.1f}bb)：{explanation}"
            wrong_answers = [
                f"不值得：高 rake 讓所有 bluff 都是 -EV",
                f"只在對手很弱時才值得",
                f"應該改成更大的 sizing 才有 EV",
            ]
        else:  # marginal
            correct_answer = f"邊際到不值得冒險 (EV = {adjusted_ev:+.2f}bb)：{explanation}"
            wrong_answers = [
                f"完全值得：EV 仍正就應該執行",
                f"完全不值得：高 rake 讓這類動作 EV = -2bb",
                f"只在 bubble 時不值得，其他時候可以",
            ]

        options = [correct_answer] + wrong_answers
        indices = list(range(len(options)))
        random.shuffle(indices)
        options = [options[i] for i in indices]
        correct_index = indices.index(0)

        # 解說
        explanation_parts = [
            f"場景：{scenario_name}",
            f"GTO EV (低 rake)：+{gto_ev:.1f}bb",
            f"Rake 成本：{rake_cost:.1f}bb",
            f"調整後 EV：{adjusted_ev:+.2f}bb",
            f"",
            f"結論：{explanation}",
            f"",
            f"通用規則：{self.rake_data.get('general_rules', {}).get('bluff_threshold', {}).get('rule', '')}",
        ]

        return LogicQuestion(
            question_type="D",
            question_text=question_text,
            options=options,
            correct_index=correct_index,
            explanation="\n".join(explanation_parts),
            tags_involved=[rake_level],
            layer="Layer 1.5 (Rake-Aware)",
            hand=scenario.get("id", ""),
            scenario=rake_level,
        )

    def generate_random_question(
        self, archetype: str = None
    ) -> Optional[LogicQuestion]:
        """隨機生成 C 或 D 類題目"""
        q_type = random.choice(["C", "D"])
        if q_type == "C":
            return self.generate_type_c(archetype=archetype)
        else:
            return self.generate_type_d()

    def generate_exploit_quiz(
        self, archetype: str = None, count: int = 5
    ) -> List[LogicQuestion]:
        """生成一組 exploit 測驗 (混合 C + D)"""
        questions = []
        attempts = 0
        max_attempts = count * 5

        while len(questions) < count and attempts < max_attempts:
            attempts += 1
            q = self.generate_random_question(archetype=archetype)
            if q:
                questions.append(q)

        return questions
